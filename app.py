from flask import Flask, render_template, request, redirect, url_for, session, flash, send_file, jsonify
from flask_compress import Compress
from werkzeug.utils import secure_filename
from models import Gym, Member, Fee, MemberNote, User, get_session
from gym_manager import GymManager
from auth_manager import AuthManager
from payment_manager import PaymentManager
from email_utils import EmailSender
import os
import json
from datetime import datetime, timedelta
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.lib.utils import ImageReader
from io import BytesIO
from google.oauth2 import id_token
from google.auth.transport import requests as google_requests
import qrcode
import base64
from dotenv import load_dotenv
from google_wallet import GymWalletPass
import stripe
import secrets
import traceback
from subscription_tiers import TIERS, TIERS_PAKISTAN, TierManager
from tier_routes import init_upgrade_routes

# Load environment variables from .env file
load_dotenv()

print("=" * 80)
print("üöÄ STARTING GYM MANAGER APPLICATION")
print("=" * 80)

# Initialize database tables on startup
try:
    from models import init_db
    print("üìä Attempting database initialization...")
    init_db()
    print("‚úÖ Database initialized successfully")
except Exception as e:
    print(f"‚ö†Ô∏è  Database init warning: {str(e)}")
    import traceback
    traceback.print_exc()

app = Flask(__name__)

# Check secret key
secret_key = os.getenv('FLASK_SECRET_KEY', 'dev-secret-key-change-in-production')
if secret_key == 'dev-secret-key-change-in-production':
    print("‚ö†Ô∏è  Using default secret key (not recommended for production)")
else:
    print("‚úÖ Custom secret key configured")
app.secret_key = secret_key

# Enable compression for all responses
Compress(app)

# Configuration
UPLOAD_FOLDER = 'static/uploads'
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size

# Create upload folder if it doesn't exist
try:
    os.makedirs(UPLOAD_FOLDER, exist_ok=True)
    os.makedirs('gym_data', exist_ok=True)
    os.makedirs('static/uploads', exist_ok=True)
    print(f"‚úÖ Directories created: {UPLOAD_FOLDER}, gym_data, static/uploads")
except Exception as e:
    print(f"‚ö†Ô∏è Directory creation warning: {str(e)}")

# Ensure users.json exists
if not os.path.exists('users.json'):
    print("Creating users.json...")
    with open('users.json', 'w') as f:
        json.dump({}, f)

auth_manager = AuthManager()
email_sender = EmailSender()
payment_manager = PaymentManager()

# Initialize Security Manager
from security_manager import SecurityManager
from models import get_session
security_manager = SecurityManager(get_session)

# Initialize modular routes (Required for Gunicorn production)
init_upgrade_routes(app, auth_manager, security_manager)

def get_gym():
    """Get GymManager instance for logged-in user"""
    if 'logged_in' not in session:
        return None
    username = session.get('username')
    return GymManager(username)  # Now uses email directly

@app.context_processor
def inject_gym_details():
    context = {}
    gym = get_gym()
    if gym:
        details = gym.get_gym_details()
        if 'currency' not in details: details['currency'] = '$'
        context['gym_details'] = details
    else:
        context['gym_details'] = {'name': 'Gym Manager', 'logo': None, 'currency': '$'}
        
    # Inject User Plan info
    if 'logged_in' in session:
        username = session.get('username')
        if auth_manager.legacy:
            user_data = auth_manager.users.get(username, {})
            context['user_plan'] = user_data.get('plan', 'standard')
        else:
            from models import User
            user = auth_manager.session.query(User).filter_by(email=username).first()
            context['user_plan'] = user.subscription_tier if user and hasattr(user, 'subscription_tier') else 'starter'
    
    return context

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

    return redirect(url_for('dashboard'))

# STRIPE CONFIGURATION - Loaded from environment variables
# Get your keys from https://dashboard.stripe.com/apikeys
app.config['STRIPE_PUBLIC_KEY'] = os.getenv('STRIPE_PUBLIC_KEY', '')
app.config['STRIPE_SECRET_KEY'] = os.getenv('STRIPE_SECRET_KEY', '')
stripe.api_key = app.config['STRIPE_SECRET_KEY']

# GOOGLE OAUTH CONFIGURATION - Loaded from environment variables
app.config['GOOGLE_CLIENT_ID'] = os.getenv('GOOGLE_CLIENT_ID', '')

# JAZZCASH CONFIGURATION
app.config['JAZZCASH_MERCHANT_ID'] = os.getenv('JAZZCASH_MERCHANT_ID', '')
app.config['JAZZCASH_PASSWORD'] = os.getenv('JAZZCASH_PASSWORD', '')
app.config['JAZZCASH_INTEGRITY_SALT'] = os.getenv('JAZZCASH_INTEGRITY_SALT', '')
app.config['JAZZCASH_RETURN_URL'] = os.getenv('JAZZCASH_RETURN_URL', 'http://localhost:5000/jazzcash_return')


@app.before_request
def check_subscription():
    # Public endpoints that don't need subscription
    public_endpoints = ['auth', 'google_login', 'static', 'subscription', 'subscription_plans', 
                       'upgrade_tier', 'upgrade_success', 'activate_trial', 'logout', 
                       'create_checkout_session', 'payment_success', 'payment_cancel', 'fix_db']
    
    if request.endpoint in public_endpoints or not session.get('logged_in'):
        return

    username = session.get('username')
    if not auth_manager.is_subscription_active(username):
        session['needs_payment'] = True
        flash('Please renew your subscription to continue using all features. (Select US or PK plan)', 'error')
        return redirect(url_for('subscription'))

# Subscription and Tier routes are now handled by tier_routes.py


#  ========== WEBHOOK MANAGEMENT ROUTES ==========

@app.route('/webhooks')
def webhooks():
    """Webhook management page"""
    from webhook_manager import WebhookManager, Webhook
    from subscription_tiers import TierManager
    
    username = session.get('username')
    if not username:
        return redirect(url_for('auth'))
    
    user = auth_manager.session.query(User).filter_by(email=username).first()
    if not user:
        return redirect(url_for('auth'))
    
    # Check if user has webhook access (Enterprise tier)
    if not TierManager.has_feature(user, 'webhooks'):
        flash('Webhooks are only available in Enterprise tier and above', 'warning')
        return redirect(url_for('subscription_plans'))
    
    # Get user's webhooks
    webhooks_list = WebhookManager.get_webhooks(user.id)
    
    return render_template('webhooks.html', 
                         webhooks=webhooks_list,
                         available_events=WebhookManager.EVENTS)


@app.route('/webhooks/create', methods=['POST'])
def create_webhook():
    """Create new webhook"""
    from webhook_manager import Webhook
    from models import get_session
    import secrets
    
    username = session.get('username')
    if not username:
        return redirect(url_for('auth'))
    
    user = auth_manager.session.query(User).filter_by(email=username).first()
    if not user:
        return redirect(url_for('auth'))
    
    name = request.form.get('name')
    url = request.form.get('url')
    events = request.form.getlist('events')
    secret = request.form.get('secret') or secrets.token_urlsafe(32)
    
    # Create webhook
    webhook_session = get_session()
    webhook = Webhook(
        user_id=user.id,
        name=name,
        url=url,
        events=json.dumps(events),
        secret=secret
    )
    
    webhook_session.add(webhook)
    webhook_session.commit()
    webhook_session.close()
    
    flash(f'‚úÖ Webhook "{name}" created successfully!', 'success')
    return redirect(url_for('webhooks'))


@app.route('/webhooks/<int:webhook_id>/toggle', methods=['POST'])
def toggle_webhook(webhook_id):
    """Enable/disable webhook"""
    from webhook_manager import Webhook
    from models import get_session
    
    username = session.get('username')
    if not username:
        return redirect(url_for('auth'))
    
    webhook_session = get_session()
    webhook = webhook_session.query(Webhook).get(webhook_id)
    
    if webhook:
        webhook.is_active = not webhook.is_active
        webhook_session.commit()
        
        status = "enabled" if webhook.is_active else "disabled"
        flash(f'Webhook {status}', 'success')
    
    webhook_session.close()
    return redirect(url_for('webhooks'))


@app.route('/webhooks/<int:webhook_id>/delete', methods=['POST'])
def delete_webhook(webhook_id):
    """Delete webhook"""
    from webhook_manager import Webhook
    from models import get_session
    
    username = session.get('username')
    if not username:
        return redirect(url_for('auth'))
    
    webhook_session = get_session()
    webhook = webhook_session.query(Webhook).get(webhook_id)
    
    if webhook:
        webhook_session.delete(webhook)
        webhook_session.commit()
        flash('üóëÔ∏è Webhook deleted', 'success')
    
    webhook_session.close()
    return redirect(url_for('webhooks'))


@app.route('/webhooks/<int:webhook_id>/test', methods=['POST'])
def test_webhook(webhook_id):
    """Test webhook with sample data"""
    from webhook_manager import WebhookManager
    
    username = session.get('username')
    if not username:
        return redirect(url_for('auth'))
    
    user = auth_manager.session.query(User).filter_by(email=username).first()
    
    # Trigger test event
    WebhookManager.trigger_event(
        user_id=user.id,
        event_type='member.created',
        data={
            'test': True,
            'member_id': 999,
            'name': 'Test Member',
            'message': 'This is a test webhook delivery'
        }
    )
    
    flash('üß™ Test webhook sent! Check logs for results.', 'info')
    return redirect(url_for('webhooks'))


@app.route('/webhooks/<int:webhook_id>/logs')
def webhook_logs(webhook_id):
    """View webhook logs"""
    from webhook_manager import WebhookManager
    
    username = session.get('username')
    if not username:
        return redirect(url_for('auth'))
    
    logs = WebhookManager.get_webhook_logs(webhook_id, limit=100)
    
    return render_template('webhook_logs.html', logs=logs, webhook_id=webhook_id)

@app.route('/create_checkout_session', methods=['POST'])
def create_checkout_session():
    username = session.get('username')
    try:
        checkout_session = stripe.checkout.Session.create(
            payment_method_types=['card'],
            line_items=[{
                'price_data': {
                    'currency': 'usd',
                    'product_data': {
                        'name': 'Gym Manager Pro Subscription',
                        'images': ['https://i.imgur.com/EHyR2nP.png'],
                    },
                    'unit_amount': 6000, # $60.00
                },
                'quantity': 1,
            }],
            mode='payment',
            success_url=url_for('payment_success', _external=True) + '?session_id={CHECKOUT_SESSION_ID}',
            cancel_url=url_for('payment_cancel', _external=True),
            client_reference_id=username,
        )
        return redirect(checkout_session.url, code=303)
    except Exception as e:
        flash(f'Error creating payment session: {str(e)}', 'error')
        return redirect(url_for('subscription'))

@app.route('/payment_success')
def payment_success():
    username = session.get('username')
    if not username: return redirect(url_for('auth'))
    
    # In a production app, verify the session_id with Stripe here
    # session_id = request.args.get('session_id')
    
    # Renew subscription
    auth_manager.renew_subscription(username)
    flash('Payment Successful! Thank you for your subscription. ‚úÖ', 'success')
    session.pop('needs_payment', None)
    return redirect(url_for('dashboard'))

@app.route('/payment_cancel')
def payment_cancel():
    flash('Payment cancelled.', 'info')
    return redirect(url_for('subscription'))

# Trial activation is now handled by tier_routes.py

@app.route('/initiate_payment', methods=['POST'])
def initiate_payment():
    """Initiate payment with selected provider"""
    username = session.get('username')
    if not username:
        flash('Please login first', 'error')
        return redirect(url_for('auth'))
    
    provider = request.form.get('provider')  # 'jazzcash', 'easypaisa', 'stripe'
    amount_pkr = 5000  # Rs 5000 for PK
    amount_usd = 60    # $60 for International
    
    # Determine amount based on provider
    if provider in ['jazzcash', 'easypaisa']:
        amount = amount_pkr
        currency = 'PKR'
    else:
        amount = amount_usd
        currency = 'USD'
    
    return_url = url_for('payment_callback', provider=provider, _external=True)
    
    # Initiate payment through PaymentManager
    result = payment_manager.initiate_payment(
        provider=provider,
        amount=amount,
        user_email=username,
        return_url=return_url,
        success_url=url_for('payment_success', _external=True),
        cancel_url=url_for('payment_cancel', _external=True)
    )
    
    if not result.get('success'):
        flash(f'Payment initiation failed: {result.get("error")}', 'error')
        return redirect(url_for('subscription'))
    
    # For Stripe, redirect to checkout URL
    if provider == 'stripe':
        return redirect(result['session_url'])
    
    # For JazzCash/EasyPaisa, render auto-submit form
    return render_template('payment_redirect.html', 
                          post_url=result['post_url'],
                          form_data=result['form_data'])

@app.route('/payment_callback/<provider>', methods=['GET', 'POST'])
def payment_callback(provider):
    """Handle payment gateway callback"""
    username = session.get('username')
    if not username:
        flash('Session expired', 'error')
        return redirect(url_for('auth'))
    
    # Get response data
    if request.method == 'POST':
        response_data = request.form.to_dict()
    else:
        response_data = request.args.to_dict()
    
    # Verify payment
    success, message = payment_manager.verify_payment(provider, response_data)
    
    if success:
        # Activate subscription
        auth_manager.extend_subscription(username, days=30)
        
        # Set market based on provider
        if provider in ['jazzcash', 'easypaisa']:
            auth_manager.set_market(username, 'PK')
        else:
            auth_manager.set_market(username, 'US')
        
        flash(f'‚úÖ Payment Successful! {message}', 'success')
        session.pop('needs_payment', None)
        return redirect(url_for('dashboard'))
    else:
        flash(f'‚ùå Payment Failed: {message}', 'error')
        return redirect(url_for('subscription'))
    
    if request.method == 'POST':
        if 'payment_proof' in request.files:
            file = request.files['payment_proof']
            if file and file.filename:
                filename = secure_filename(f"proof_{username}_{datetime.now().strftime('%Y%m%d%H%M%S')}_{file.filename}")
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                file.save(filepath)
                
                # Update user status to pending
                auth_manager.set_payment_pending(username, filename)
                
                flash('Proof uploaded! Waiting for admin approval.', 'success')
                return redirect(url_for('subscription'))
                
    return render_template('payment_manual.html')

# Admin Access Control - Loaded from environment variables
ADMIN_EMAILS = os.getenv('ADMIN_EMAILS', 'admin@gym.com').split(',')

@app.route('/super_admin')
def super_admin():
    if session.get('username') not in ADMIN_EMAILS:
        flash('Access Denied: Super Admin only.', 'error')
        return redirect(url_for('dashboard'))
    
    pending_users = auth_manager.get_pending_approvals()
    return render_template('super_admin.html', pending_users=pending_users)

@app.route('/approve_payment/<target_username>')
def approve_payment(target_username):
    if session.get('username') not in ADMIN_EMAILS:
        flash('Access Denied.', 'error')
        return redirect(url_for('dashboard'))
        
    # Verify admin here logic
    if auth_manager.approve_manual_payment(target_username):
        flash(f'User {target_username} approved!', 'success')
        
        # Optional: Add a real Stripe payment record or just the manual one (already done in AuthManager)
    else:
        flash('Approval failed.', 'error')
    return redirect(url_for('super_admin'))

@app.route('/auth', methods=['GET', 'POST'])
def auth():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        action = request.form.get('action')
        referral_code = request.form.get('referral_code')
        
        if action == 'signup':
            if auth_manager.create_user(username, password, referral_code):
                flash('Account created successfully! Please login.', 'success')
                return redirect(url_for('auth'))
            else:
                flash('Username already exists!', 'error')
        
        elif action == 'login':
            if auth_manager.verify_user(username, password):
                session['logged_in'] = True
                session['username'] = username
                
                # Production Security: Log Audit & Session
                user_id = auth_manager.get_user_id(username)
                if user_id:
                    token = security_manager.create_session_token()
                    session['session_token'] = token
                    security_manager.track_session(user_id, token, request.remote_addr, request.user_agent.string)
                    security_manager.log_action(user_id, 'LOGIN_SUCCESS', {'ip': request.remote_addr}, request.remote_addr, request.user_agent.string)
                
                flash('Login successful!', 'success')
                return redirect(url_for('dashboard'))
            else:
                user_id = auth_manager.get_user_id(username)
                if user_id:
                    security_manager.log_action(user_id, 'LOGIN_FAILURE', {'ip': request.remote_addr}, request.remote_addr, request.user_agent.string)
                flash('Invalid credentials!', 'error')
    
    return render_template('auth.html')

@app.route('/google_login', methods=['POST'])
def google_login():
    token = request.form.get('credential')
    try:
        # Specify the CLIENT_ID of the app that accesses the backend (from environment variables)
        client_id = os.getenv('GOOGLE_CLIENT_ID', '')
        if not client_id:
            flash('Google Login not configured. Please contact administrator.', 'error')
            return redirect(url_for('auth'))
        idinfo = id_token.verify_oauth2_token(token, google_requests.Request(), client_id)

        # ID token is valid. Get the user's Google Account ID from the decoded token.
        email = idinfo['email']

        # Ensure user exists in our system
        if not auth_manager.user_exists(email):
            # Auto-signup with "GOOGLE" referral/plan logic if needed, or default free?
            # User asked for: "referral mera jo hoga wo bs free ho single time use"
            # We'll treat Google signups as standard/free for now.
            auth_manager.create_user(email, "GOOGLE_AUTH_USER", referral_code="GOOGLE_SIGNUP")
            flash(f'Account created with Google! Welcome, {email}.', 'success')

        session['logged_in'] = True
        session['username'] = email

        if auth_manager.user_exists(email):
             flash(f'Logged in as {email}!', 'success')

        return redirect(url_for('dashboard'))
    except ValueError:
        # Invalid token
        flash('Google Login failed! Invalid token.', 'error')
        return redirect(url_for('auth'))

@app.route('/logout')
def logout():
    session.clear()
    flash('Logged out successfully!', 'success')
    return redirect(url_for('auth'))

@app.route('/forgot_password', methods=['GET', 'POST'])
def forgot_password():
    """Request password reset code"""
    if request.method == 'POST':
        email = request.form.get('email', '').strip()
        
        if not email:
            flash('Please enter your email address.', 'error')
            return redirect(url_for('forgot_password'))
        
        # Check if user exists
        if not auth_manager.user_exists(email):
            flash('No account found with that email.', 'error')
            return redirect(url_for('forgot_password'))
        
        # Generate reset code
        reset_code = auth_manager.generate_reset_code(email)
        
        if reset_code:
            # Try to send email
            from email_utils import EmailSender
            email_sender = EmailSender()
            
            if email_sender.is_configured():
                email_sender.send_reset_code(email, reset_code, email)
                flash(f'Reset code sent to {email}! Check your email.', 'success')
            else:
                # Email not configured - show code on screen (dev mode)
                flash(f'‚ö†Ô∏è Email not configured. Your reset code is: {reset_code}', 'warning')
            
            # Redirect to reset page
            return redirect(url_for('reset_password', email=email))
        else:
            flash('Error generating reset code. Please try again.', 'error')
    
    return render_template('forgot_password.html')

@app.route('/reset_password', methods=['GET', 'POST'])
def reset_password():
    """Verify code and reset password"""
    email = request.args.get('email') or request.form.get('email')
    
    if not email:
        flash('Invalid reset link.', 'error')
        return redirect(url_for('forgot_password'))
    
    if request.method == 'POST':
        code = request.form.get('code', '').strip()
        new_password = request.form.get('new_password', '').strip()
        confirm_password = request.form.get('confirm_password', '').strip()
        
        # Validate inputs
        if not code or not new_password or not confirm_password:
            flash('Please fill all fields.', 'error')
            return render_template('reset_password.html', email=email)
        
        if new_password != confirm_password:
            flash('Passwords do not match!', 'error')
            return render_template('reset_password.html', email=email)
        
        if len(new_password) < 6:
            flash('Password must be at least 6 characters.', 'error')
            return render_template('reset_password.html', email=email)
        
        # Verify code
        if auth_manager.verify_reset_code(email, code):
            # Reset password
            if auth_manager.reset_password(email, new_password):
                # Send confirmation email
                from email_utils import EmailSender
                email_sender = EmailSender()
                if email_sender.is_configured():
                    email_sender.send_password_changed_notification(email, email)
                
                flash('‚úÖ Password reset successful! Please login with your new password.', 'success')
                return redirect(url_for('auth'))
            else:
                flash('Error resetting password. Please try again.', 'error')
        else:
            flash('‚ùå Invalid or expired code. Please request a new one.', 'error')
            return redirect(url_for('forgot_password'))
    
    return render_template('reset_password.html', email=email)


@app.route('/schedule', methods=['GET', 'POST'])
def schedule():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    if request.method == 'POST':
        name = request.form.get('name')
        day = request.form.get('day')
        time = request.form.get('time')
        instructor = request.form.get('instructor')
        capacity = request.form.get('capacity')
        
        gym.add_class(name, day, time, instructor, capacity)
        flash('Class added successfully!', 'success')
        return redirect(url_for('schedule'))
        
    return render_template('schedule.html', classes=gym.get_classes(), members=gym.get_all_members())

@app.route('/expenses', methods=['GET', 'POST'])
def expenses():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    if request.method == 'POST':
        category = request.form.get('category')
        amount = float(request.form.get('amount') or 0)
        date = request.form.get('date')
        description = request.form.get('description', '')
        
        if gym.add_expense(category, amount, date, description):
            flash(f'Expense of {amount} recorded successfully!', 'success')
        else:
            flash('Failed to add expense!', 'error')
        
        return redirect(url_for('expenses'))
    
    # Get current month
    current_month = datetime.now().strftime('%Y-%m')
    
    # Get expenses for current month
    expenses_list = gym.get_expenses(current_month)
    
    # Calculate P&L
    pl_data = gym.calculate_profit_loss(current_month)
    
    # Available months for dropdown
    available_months = []
    for i in range(12):
        month_date = datetime.now() - timedelta(days=30*i)
        available_months.append({
            'value': month_date.strftime('%Y-%m'),
            'label': month_date.strftime('%B %Y')
        })
    
    return render_template('expenses.html',
                         expenses=expenses_list,
                         pl_data=pl_data,
                         current_month=current_month,
                         available_months=available_months,
                         gym_details=gym.get_gym_details())

@app.route('/delete_expense/<expense_id>', methods=['POST'])
def delete_expense(expense_id):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    if gym.delete_expense(expense_id):
        flash('Expense deleted successfully!', 'success')
    else:
        flash('Failed to delete expense!', 'error')
    
    return redirect(url_for('expenses'))

@app.route('/book_class/<class_id>', methods=['POST'])
def book_class(class_id):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    member_id = request.form.get('member_id')
    if gym.book_class(member_id, class_id):
        flash('Booking confirmed!', 'success')
    else:
        flash('Booking failed (Full or invalid)', 'error')
        
    return redirect(url_for('schedule'))

@app.route('/reports')
def reports():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    # Calculate stats
    total_members = len(gym.get_all_members())
    
    # Current month revenue
    current_month = datetime.now().strftime('%Y-%m')
    status = gym.get_payment_status(current_month)
    monthly_revenue = sum(m.get('amount', 0) for m in status['paid'])
    
    # Total check-ins
    total_checkins = 0
    if gym.legacy and hasattr(gym, 'data') and 'attendance' in gym.data:
        for visits in gym.data['attendance'].values():
            total_checkins += len(visits)
    elif not gym.legacy:
        # Database mode - count attendance records
        try:
            from models import get_session, Attendance
            session = get_session()
            if session:
                total_checkins = session.query(Attendance).count()
                session.close()
        except:
            total_checkins = 0
    
    # Revenue trend (last 6 months)
    revenue_months = []
    revenue_data = []
    for i in range(5, -1, -1):
        month = (datetime.now().replace(day=1) - timedelta(days=30*i)).strftime('%Y-%m')
        revenue_months.append(month)
        month_status = gym.get_payment_status(month)
        revenue_data.append(sum(m.get('amount', 0) for m in month_status['paid']))
    
    return render_template('reports.html',
                         total_members=total_members,
                         monthly_revenue=monthly_revenue,
                         total_checkins=total_checkins,
                         paid_count=len(status['paid']),
                         unpaid_count=len(status['unpaid']),
                         revenue_months=revenue_months,
                         revenue_data=revenue_data)

@app.route('/reset_admin')
def reset_admin():
    gym = get_gym()
    if gym:
        gym.reset_data()
        flash('All your data has been reset!', 'success')
    # Use referer check or just redirect dashboard to force re-login check? 
    # Actually, reset_data keeps the file but empties content. User is still logged in.
    return redirect(url_for('dashboard'))

@app.route('/dashboard')
def dashboard():
    try:
        gym = get_gym()
        if not gym: return redirect(url_for('auth'))

        # Generate months for dropdown (using standard datetime instead of pandas for compatibility)
        current_date = datetime.now()
        available_months = []
        for i in range(37):
            # Go back i months from current month
            year = current_date.year
            month = current_date.month - i
            while month <= 0:
                month += 12
                year -= 1
            date_obj = datetime(year, month, 1)
            available_months.append(date_obj.strftime('%Y-%m'))
        
        # Check if month requested
        current_month = request.args.get('month')
        if not current_month:
            current_month = datetime.now().strftime('%Y-%m')
            
        # ====================== ULTIMATE PERFORMANCE FIX ======================
        # Fetch EVERYTHING in one go using optimized SQL queries
        stats, alerts, charts = gym.get_dashboard_stats()
        
        # Fallback for handling empty data/errors
        revenue_trend = charts.get('revenue_trend', [])
        max_revenue = max([r['revenue'] for r in revenue_trend]) if revenue_trend else 1
        
        return render_template('dashboard_enhanced.html',
                            # Stats
                            total_members=stats.get('total_members', 0),
                            paid=stats.get('paid_list', []), # Fixed: Pass LIST not COUNT
                            unpaid=stats.get('unpaid_list', []), # Fixed: Pass LIST not COUNT
                            revenue=stats.get('revenue', 0),
                            revenue_change=stats.get('revenue_change', 0),
                            expiring_count=stats.get('expiring_count', 0),
                            
                            # Helper data
                            current_month=current_month,
                            available_months=available_months,
                            gym_details=gym.get_gym_details(),
                            
                            # Charts
                            revenue_trend=revenue_trend,
                            max_revenue=max_revenue,
                            
                            # Smart Alerts lists
                            unpaid_members_alert=alerts.get('unpaid', []),
                            expiring_trials_alert=alerts.get('expiring', []),
                            birthdays_today_alert=alerts.get('birthdays', []),
                            inactive_members_alert=alerts.get('inactive', [])
                            )
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        return f"<h1>Global Error Handler</h1><pre>{error_details}</pre>", 500


@app.route('/analytics')
def analytics():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    all_members = gym.get_all_members()
    total_members = len(all_members)
    
    # Calculate Member Growth (last 6 months)
    member_growth = []
    max_growth = 0
    current_date = datetime.now()
    
    for i in range(5, -1, -1):
        year = current_date.year
        month = current_date.month - i
        while month <= 0:
            month += 12
            year -= 1
        
        month_start = datetime(year, month, 1).date()
        if month == 12:
            month_end = datetime(year + 1, 1, 1).date()
        else:
            month_end = datetime(year, month + 1, 1).date()
        
        # Count members who joined in this month
        count = sum(1 for m in all_members 
                   if m.get('joined_date') and 
                   month_start <= datetime.strptime(str(m['joined_date']), '%Y-%m-%d').date() < month_end)
        
        member_growth.append({
            'month': datetime(year, month, 1).strftime('%b'),
            'count': count
        })
        max_growth = max(max_growth, count)
    
    # Calculate Retention Rate (members who renewed this month)
    current_month = datetime.now().strftime('%Y-%m')
    last_month = (datetime.now().replace(day=1) - timedelta(days=1)).strftime('%Y-%m')
    
    paid_this_month = sum(1 for m in all_members if gym.is_fee_paid(m['id'], current_month))
    paid_last_month = sum(1 for m in all_members if gym.is_fee_paid(m['id'], last_month))
    
    retention_rate = round((paid_this_month / paid_last_month * 100), 1) if paid_last_month > 0 else 100
    
    # Total Check-ins (this month)
    total_checkins = 0
    month_start = datetime.now().replace(day=1)
    
    for member in all_members:
        attendance = gym.get_attendance(member['id'])
        for record in attendance:
            try:
                checkin_date = datetime.strptime(record['timestamp'], '%Y-%m-%d %H:%M:%S')
                if checkin_date >= month_start:
                    total_checkins += 1
            except:
                pass
    
    # Attendance Heatmap (Day of week vs Hour)
    heatmap_data = {}
    max_attendance = 0
    
    for member in all_members:
        attendance = gym.get_attendance(member['id'])
        for record in attendance:
            try:
                checkin_time = datetime.strptime(record['timestamp'], '%Y-%m-%d %H:%M:%S')
                day_of_week = checkin_time.weekday()  # 0=Monday, 6=Sunday
                hour = checkin_time.hour
                
                key = (day_of_week, hour)
                heatmap_data[key] = heatmap_data.get(key, 0) + 1
                max_attendance = max(max_attendance, heatmap_data[key])
            except:
                pass
    
    # Top Performers (Most active members)
    member_checkins = []
    for member in all_members:
        attendance = gym.get_attendance(member['id'])
        checkin_count = len(attendance)
        if checkin_count > 0:
            member_checkins.append({
                'name': member['name'],
                'phone': member['phone'],
                'checkins': checkin_count
            })
    
    # Sort and get top 5
    top_performers = sorted(member_checkins, key=lambda x: x['checkins'], reverse=True)[:5]
    
    return render_template('analytics.html',
                         total_members=total_members,
                         retention_rate=retention_rate,
                         total_checkins=total_checkins,
                         member_growth=member_growth,
                         max_growth=max_growth if max_growth > 0 else 1,
                         heatmap_data=heatmap_data,
                         max_attendance=max_attendance if max_attendance > 0 else 1,
                         top_performers=top_performers)

@app.route('/advanced-analytics')
def advanced_analytics():
    """Advanced Analytics optimized with Batch Data Engine"""
    gym_man = get_gym()
    if not gym_man: return redirect(url_for('auth'))
    
    # Use high-performance batch engine
    data = gym_man.get_batch_analytics_data()
    if not data or not data['members']:
        flash('No data available for analytics yet.', 'info')
        return redirect(url_for('dashboard'))
        
    metrics = gym_man.calculate_business_metrics(data)
    
    # Additional data for UI charts
    growth_months = metrics['forecast_months'][:6]
    new_members_data = [] # Logic moved to metrics in future, currently 0 for churn logic
    for i in range(5, -1, -1):
        date = datetime.now() - timedelta(days=30*i)
        month_str = date.strftime('%Y-%m')
        new_members_data.append(sum(1 for m in data['members'] if m.joined_date and m.joined_date.strftime('%Y-%m') == month_str))
    
    churned_members_data = metrics['churn_trend']
    membership_types = ['Gym', 'Gym + Cardio', 'Personal Training', 'Other']
    revenue_by_type = [0] * 4
    
    # Calculate revenue by type in-memory from batch fees
    current_month = datetime.now().strftime('%Y-%m')
    member_map = {m.id: m for m in data['members']}
    for fee in data['fees']:
        if fee.month == current_month:
            m = member_map.get(fee.member_id)
            if m:
                try:
                    idx = membership_types.index(m.membership_type)
                    revenue_by_type[idx] += float(fee.amount)
                except:
                    revenue_by_type[3] += float(fee.amount)
                    
    # Intelligent Insights
    insights = []
    if metrics['revenue_growth'] > 10:
        insights.append({'type': 'success', 'icon': 'üìà', 'title': 'Revenue Surge', 'message': f'Revenue increased by {metrics["revenue_growth"]}%! Your growth strategy is working.'})
    elif metrics['revenue_growth'] < -10:
        insights.append({'type': 'warning', 'icon': '‚ö†Ô∏è', 'title': 'Revenue Warning', 'message': f'Revenue dropped by {abs(metrics["revenue_growth"])}%. Check for churn or late payments.'})
        
    if metrics['at_risk_count'] > 5:
        insights.append({'type': 'danger', 'icon': 'üö®', 'title': 'At-Risk Members', 'message': f'{metrics["at_risk_count"]} members are at risk of churning (no attendance in 7 days).'})

    return render_template('advanced_analytics.html',
                         total_revenue=metrics['total_revenue'],
                         revenue_growth=metrics['revenue_growth'],
                         total_members=len(data['members']),
                         new_members_this_month=new_members_data[-1],
                         retention_rate=metrics['retention_rate'],
                         avg_attendance=round(len(data['attendance']) / 30, 1),
                         peak_hour=metrics['peak_hour'],
                         forecast_months=metrics['forecast_months'],
                         actual_revenue=metrics['actual_revenue'],
                         forecasted_revenue=metrics['forecasted_revenue'],
                         growth_months=growth_months,
                         new_members_data=new_members_data,
                         churned_members_data=churned_members_data,
                         membership_types=membership_types,
                         revenue_by_type=revenue_by_type,
                         collection_months=metrics['collection_months'],
                         collection_rates=metrics['collection_rates'],
                         heatmap_hours=metrics['heatmap_hours'],
                         heatmap_data=metrics['heatmap_data'],
                            insights=insights,
                         vip_count=metrics['vip_count'],
                         active_count=metrics['active_count'],
                         at_risk_count=metrics['at_risk_count'],
                         churned_count=metrics['churned_count'])
    
@app.route('/bulk-operations')
def bulk_operations():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    all_members = gym.get_all_members()
    current_month = datetime.now().strftime('%Y-%m')
    
    # Add is_paid status to members
    for member in all_members:
        member['is_paid'] = gym.is_fee_paid(member['id'], current_month)
    
    # Generate months
    current_date = datetime.now()
    available_months = []
    for i in range(12):
        year = current_date.year
        month = current_date.month - i
        while month <= 0:
            month += 12
            year -= 1
        available_months.append(f"{year}-{month:02d}")
    
    return render_template('bulk_operations.html',
                         members=all_members,
                         current_month=current_month,
                         available_months=available_months)

@app.route('/bulk-payment', methods=['POST'])
def bulk_payment():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    member_ids = request.form.get('member_ids', '').split(',')
    month = request.form.get('month')
    amount = float(request.form.get('amount', 0))
    
    success_count = 0
    for member_id in member_ids:
        if member_id.strip():
            if gym.pay_fee(member_id.strip(), month, amount, datetime.now().strftime('%Y-%m-%d')):
                success_count += 1
    
    flash(f'‚úÖ Successfully recorded {success_count} payments!', 'success')
    return redirect(url_for('bulk_operations'))



@app.route('/add_member', methods=['GET', 'POST'])
def add_member():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    # Generate months for dropdown
    current_date = datetime.now()
    available_months = []
    # Generate 12 past months, current month, and 24 future months (total 37)
    # Start from 12 months ago and go forward
    start_month_calc = current_date.replace(day=1) - timedelta(days=365) # Roughly 12 months ago
    
    for i in range(37):
        # Calculate month by adding i months to the start_month_calc
        year = start_month_calc.year
        month = start_month_calc.month + i
        
        while month > 12:
            month -= 12
            year += 1
        
        date_obj = datetime(year, month, 1)
        available_months.append({
            'value': date_obj.strftime('%Y-%m'),
            'label': date_obj.strftime('%B %Y')
        })
    
    # Reverse to show future months first, then current, then past
    available_months.reverse()
    
    if request.method == 'POST':
        name = request.form.get('name')
        phone = request.form.get('phone')
        membership_type = request.form.get('membership_type', 'Gym')
        
        # Initial Payment data
        initial_month = request.form.get('initial_month')
        try:
            initial_amount = float(request.form.get('initial_amount', 0) or 0)
        except ValueError:
            initial_amount = 0
            
        photo_path = None
        
        # Handle file upload
        if 'photo' in request.files:
            file = request.files['photo']
            if file and file.filename and allowed_file(file.filename):
                filename = secure_filename(f"{datetime.now().strftime('%Y%m%d%H%M%S')}_{file.filename}")
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                file.save(filepath)
                photo_path = filename
        
        # Handle camera capture (base64 data)
        elif 'camera_photo' in request.form and request.form['camera_photo']:
            import base64
            photo_data = request.form['camera_photo'].split(',')[1]
            photo_bytes = base64.b64decode(photo_data)
            filename = f"camera_{datetime.now().strftime('%Y%m%d%H%M%S')}.png"
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            with open(filepath, 'wb') as f:
                f.write(photo_bytes)
            photo_path = filename
        
        try:
            membership_type = request.form.get('membership_type', 'Gym')
            joined_date = request.form.get('joined_date')
            email = request.form.get('email')
            start_trial = request.form.get('start_trial') == 'on'
            
            # If initial payment overrides trial, we can decide logic.
            # Here: If they pay, trial is False. If they don't and check trial, it's True.
            if initial_amount > 0:
                start_trial = False
                
            member_id = gym.add_member(name, phone, photo_path, membership_type, joined_date, is_trial=start_trial, email=email)
            
            # Record initial payment if amount > 0
            if initial_amount > 0 and initial_month:
                gym.pay_fee(member_id, initial_month, initial_amount)
                flash(f'Member {name} added and payment recorded for {initial_month}!', 'success')
            elif start_trial:
                flash(f'Member {name} added on 3-Day Free Trial! üÜì', 'success')
            else:
                flash(f'Member {name} added successfully! (ID: {member_id})', 'success')
                
            return redirect(url_for('dashboard'))
            
        except Exception as e:
            flash(f'Error adding member: {str(e)}', 'error')
            return redirect(url_for('add_member'))
    
    return render_template('add_member.html', 
                         available_months=available_months, 
                         current_month=current_date.strftime('%Y-%m'),
                         today=current_date.strftime('%Y-%m-%d'))

@app.route('/fees', methods=['GET', 'POST'])
def fees():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    if request.method == 'POST':
        member_id = request.form.get('member_id')
        month = request.form.get('month')
        amount = float(request.form.get('amount') or 0)
        notes = request.form.get('notes', '')
        
        if gym.pay_fee(member_id, month, amount, notes):
            member = gym.get_member(member_id)
            flash(f'Fee recorded for {member["name"]} for {month}', 'success')
        else:
            flash('Member not found!', 'error')
        
        return redirect(url_for('fees'))
    
    # Get current month
    current_month = datetime.now().strftime('%Y-%m')
    
    # Get all payment records across all members for this gym
    fees_query = gym.session.query(Fee).join(Member).filter(Member.gym_id == gym.gym.id).order_by(Fee.paid_date.desc())
    fees_list = fees_query.all()
    
    # Calculate summary
    total_collected = sum(f.amount for f in fees_list)
    current_month_records = [f for f in fees_list if f.month == current_month]
    current_month_total = sum(f.amount for f in current_month_records)
    
    # Get all members for the dropdown
    all_members = gym.get_all_members()
    
    # Get paid/unpaid members for current month
    paid_members = []
    unpaid_members = []
    
    for member in all_members:
        is_paid = gym.is_fee_paid(member['id'], current_month)
        if is_paid:
            paid_members.append(member)
        else:
            unpaid_members.append(member)
    
    # Generate months for dropdown (using standard datetime instead of pandas for compatibility)
    current_date = datetime.now()
    available_months = []
    for i in range(37):
        # Go back i months from current month
        year = current_date.year
        month = current_date.month - i
        while month <= 0:
            month += 12
            year -= 1
        date_obj = datetime(year, month, 1)
        available_months.append({
            'value': date_obj.strftime('%Y-%m'),
            'label': date_obj.strftime('%B %Y')
        })
    
    return render_template('fees.html', 
                         members=all_members,
                         paid_members=paid_members,
                         unpaid_members=unpaid_members,
                         fees=fees_list,
                         current_month=current_month,
                         available_months=available_months,
                         total_collected=total_collected,
                         current_month_total=current_month_total,
                         gym_details=gym.get_gym_details())

@app.route('/download_excel')
def download_excel():
    """Quick export - dashboard members list"""
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    current_month = datetime.now().strftime('%Y-%m')
    all_members = gym.get_all_members()
    
    # Prepare comprehensive data for Excel
    data = []
    for member in all_members:
        # Check payment status
        is_paid = gym.is_fee_paid(member['id'], current_month)
        
        data.append({
            'ID': member['id'],
            'Name': member['name'],
            'Phone': member['phone'],
            'Email': member.get('email', 'N/A'),
            'Membership Type': member.get('membership_type', 'Gym'),
            'Join Date': member.get('joined_date', 'N/A'),
            'Status': 'PAID' if is_paid else 'UNPAID',
            'Active': 'Yes' if member.get('active', True) else 'No'
        })
    
    df = pd.DataFrame(data)
    
    # Create Excel file with formatting
    output = BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df.to_excel(writer, index=False, sheet_name='Members')
        
        # Get workbook and worksheet
        worksheet = writer.sheets['Members']
        
        # Auto-adjust column widths
        for column in worksheet.columns:
            max_length = 0
            column = [cell for cell in column]
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = (max_length + 2)
            worksheet.column_dimensions[column[0].column_letter].width = adjusted_width
    
    output.seek(0)
    
    filename = f'gym_members_{current_month}.xlsx'
    return send_file(output, download_name=filename, as_attachment=True)

# ==================== ADVANCED EXPORT CENTER ====================

@app.route('/export_center')
def export_center():
    """Export Center - Dashboard for all export options"""
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    return render_template('export_center.html')

@app.route('/export/members_complete')
def export_members_complete():
    """Export complete member database"""
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    from export_manager import ExportManager
    export_mgr = ExportManager(gym)
    
    output = export_mgr.export_members_complete()
    filename = f'members_complete_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xlsx'
    
    return send_file(output, download_name=filename, as_attachment=True, mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')

@app.route('/export/revenue_report')
def export_revenue_report():
    """Export revenue report"""
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    from export_manager import ExportManager
    export_mgr = ExportManager(gym)
    
    # Get date range from query params
    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')
    
    output = export_mgr.export_revenue_report(start_date, end_date)
    filename = f'revenue_report_{datetime.now().strftime("%Y%m%d")}.xlsx'
    
    return send_file(output, download_name=filename, as_attachment=True, mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')

@app.route('/export/unpaid_members')
def export_unpaid_members():
    """Export unpaid members list"""
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    from export_manager import ExportManager
    export_mgr = ExportManager(gym)
    
    output = export_mgr.export_unpaid_members()
    filename = f'unpaid_members_{datetime.now().strftime("%Y%m%d")}.xlsx'
    
    return send_file(output, download_name=filename, as_attachment=True, mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')

@app.route('/card/<member_id>')
def generate_card(member_id):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    member = gym.get_member(member_id)
    if not member:
        flash('Member not found!', 'error')
        return redirect(url_for('dashboard'))
    
    # Create PDF
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter
    
    # Card background
    c.setFillColorRGB(0.1, 0.1, 0.2)
    c.rect(50, height - 350, 300, 200, fill=True)
    
    # Title
    c.setFillColorRGB(1, 1, 1)
    c.setFont("Helvetica-Bold", 20)
    c.drawString(70, height - 180, "GYM MEMBER CARD")
    
    # Member photo
    if member.get('photo'):
        photo_path = os.path.join(app.config['UPLOAD_FOLDER'], member['photo'])
        if os.path.exists(photo_path):
            try:
                img = ImageReader(photo_path)
                c.drawImage(img, 70, height - 330, width=80, height=100, preserveAspectRatio=True)
            except:
                pass
    
    # QR Code
    qr = qrcode.QRCode(version=1, box_size=10, border=2)
    qr.add_data(member_id)
    qr.make(fit=True)
    qr_img = qr.make_image(fill_color="black", back_color="white")
    
    # Save QR to buffer to draw
    qr_buffer = BytesIO()
    qr_img.save(qr_buffer)
    qr_buffer.seek(0)
    
    # Draw QR Code on card
    c.drawImage(ImageReader(qr_buffer), 270, height - 330, width=70, height=70)
    
    # Member details
    c.setFont("Helvetica", 12)
    c.drawString(170, height - 230, f"ID: {member['id']}")
    c.drawString(170, height - 250, f"Name: {member['name']}")
    c.drawString(170, height - 270, f"Phone: {member['phone']}")
    c.drawString(170, height - 290, f"Joined: {member['joined_date']}")
    
    c.save()
    buffer.seek(0)
    
    return send_file(buffer, download_name=f'card_{member_id}.pdf', as_attachment=True, mimetype='application/pdf')

@app.route('/scanner')
def scanner():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    return render_template('scanner.html')

@app.route('/scan_check/<member_id>')
def scan_check(member_id):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    # Determine status
    current_month = datetime.now().strftime('%Y-%m')
    is_paid = gym.is_fee_paid(member_id, current_month)
    member = gym.get_member(member_id)
    
    if not member:
        flash('Invalid Member ID!', 'error')
        return redirect(url_for('scanner'))
        
    status = 'GRANTED' if is_paid else 'DENIED'
    status = ''
    if is_paid:
        status = 'ACCESS GRANTED'
        # Log attendance automatically
        gym.log_attendance(member_id)
    # Special check for trial
    elif not is_paid and member.get('is_trial'):
        today = datetime.now().strftime('%Y-%m-%d')
        if member.get('trial_end_date') >= today:
             status = 'TRIAL'
        else:
            status = 'ACCESS DENIED - TRIAL EXPIRED'
    else:
        status = 'ACCESS DENIED - FEE PENDING'
    
    # Get attendance history
    attendance_history = gym.get_attendance(member_id)
    
    # Get payment details
    payment_history = gym.get_member_fees(member_id)
    last_payment = payment_history[0] if payment_history else None
             
    return render_template('scan_result.html', 
                         member=member, 
                         status=status, 
                         month=current_month,
                         attendance_history=attendance_history,
                         last_payment=last_payment,
                         is_paid=is_paid,
                         gym_details=gym.get_gym_details())

@app.route('/member/<member_id>', methods=['GET', 'POST'])
def member_details(member_id):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    member = gym.get_member(member_id)
    if not member:
        flash('Member not found!', 'error')
        return redirect(url_for('dashboard'))
        
    # Safe data fetching to prevent 500 errors if DB schema is mismatched
    attendance_history = []
    fees_history = []
    try:
        attendance_history = gym.get_attendance(member_id)
        fees_history = gym.get_member_fees(member_id)
    except Exception as e:
        print(f"‚ö†Ô∏è DB Error fetching details: {str(e)}")
        flash(f'Database Schema Error: {str(e)}', 'error')
        flash('‚ö†Ô∏è Please run the Database Fix Tool to repair this!', 'warning')
        # We don't return here, we let the page load with empty history so user can see the "Fix DB" button
    
    if request.method == 'POST':
        month = request.form.get('month')
        amount = float(request.form.get('amount') or 0)
        payment_date = request.form.get('payment_date')
        notes = request.form.get('notes')
        
        if gym.pay_fee(member_id, month, amount, payment_date, notes):
            flash(f'Payment recorded successfully for {month}!', 'success')
        else:
            flash('Payment failed!', 'error')
        return redirect(url_for('member_details', member_id=member_id))
    
    
    # Generate months for payment dropdown (using standard datetime instead of pandas for compatibility)
    current_date = datetime.now()
    available_months = []
    for i in range(37):
        # Go back i months from current month
        year = current_date.year
        month = current_date.month - i
        while month <= 0:
            month += 12
            year -= 1
        date_obj = datetime(year, month, 1)
        available_months.append({
            'value': date_obj.strftime('%Y-%m'),
            'label': date_obj.strftime('%B %Y')
        })
    
    return render_template('member_details.html', 
                         member=member, 
                         gym_details=gym.get_gym_details(), 
                         history=fees_history,
                         attendance_history=attendance_history,
                         current_month=datetime.now().strftime('%Y-%m'),
                         today=datetime.now().strftime('%Y-%m-%d'),
                         available_months=available_months,
                         notes=gym.get_member_notes(member_id),
                         timeline=gym.get_member_timeline(member_id),
                         measurements=gym.get_body_measurements(member_id))

@app.route('/member/<member_id>/add_note', methods=['POST'])
def add_member_note(member_id):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    note_text = request.form.get('note')
    if note_text and note_text.strip():
        if gym.add_member_note(member_id, note_text.strip()):
            flash('üìù Note added successfully!', 'success')
        else:
            flash('Failed to add note', 'error')
    
    return redirect(url_for('member_details', member_id=member_id))

@app.route('/member/<member_id>/delete_note/<note_id>')
def delete_member_note(member_id, note_id):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    if gym.delete_member_note(note_id):
        flash('üóëÔ∏è Note deleted!', 'success')
    else:
        flash('Failed to delete note', 'error')
    
    return redirect(url_for('member_details', member_id=member_id))

@app.route('/member/<member_id>/add-measurement', methods=['POST'])
def add_measurement(member_id):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    weight = request.form.get('weight')
    body_fat = request.form.get('body_fat')
    chest = request.form.get('chest')
    waist = request.form.get('waist')
    arms = request.form.get('arms')
    notes = request.form.get('notes')
    
    if weight:
        if gym.add_body_measurement(member_id, weight, body_fat, chest, waist, arms, notes):
            flash('üìä Measurement recorded successfully!', 'success')
        else:
            flash('Failed to add measurement', 'error')
    
    return redirect(url_for('member_details', member_id=member_id))

@app.route('/member/<member_id>/delete-measurement/<measurement_id>')
def delete_measurement(member_id, measurement_id):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    if gym.delete_body_measurement(measurement_id):
        flash('üóëÔ∏è Measurement deleted!', 'success')
    else:
        flash('Failed to delete measurement', 'error')
    
    return redirect(url_for('member_details', member_id=member_id))



@app.route('/member/<member_id>/delete_fee/<month>', methods=['POST'])
def delete_fee_record(member_id, month):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    if gym.delete_fee(member_id, month):
        flash(f'Payment for {month} deleted!', 'success')
    else:
        flash('Delete failed!', 'error')
        
    return redirect(url_for('member_details', member_id=member_id))

@app.route('/member/<member_id>/edit_fee/<month>', methods=['GET', 'POST'])
def edit_fee_record(member_id, month):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    member = gym.get_member(member_id)
    if not member or not gym.is_fee_paid(member_id, month):
        flash('Fee record not found!', 'error')
        return redirect(url_for('member_details', member_id=member_id))
        
    if request.method == 'POST':
        try:
            amount = float(request.form.get('amount') or 0)
            date = request.form.get('date') # Expecting YYYY-MM-DD HH:MM:SS or just date
            
            if gym.update_fee(member_id, month, amount, date):
                flash(f'Payment for {month} updated!', 'success')
                return redirect(url_for('member_details', member_id=member_id))
            else:
                flash('Update failed!', 'error')
        except ValueError:
            flash('Invalid amount!', 'error')
            
    # Get current fee data
    fee_info = None
    if gym.legacy and hasattr(gym, 'data'):
        if member_id in gym.data.get('fees', {}) and month in gym.data['fees'][member_id]:
            fee_info = gym.data['fees'][member_id][month]
    else:
        # Database mode - get from Fee table
        try:
            # Use the gym's existing session if available, or create new one properly
            if hasattr(gym, 'session'):
                session = gym.session
            else:
                from models import get_session
                session = get_session()
                
            if session:
                from models import Fee
                fee = session.query(Fee).filter_by(member_id=int(member_id), month=month).first()
                if fee:
                    fee_info = {
                        'amount': fee.amount,
                        'date': fee.paid_date.strftime('%Y-%m-%d %H:%M:%S') if fee.paid_date else '',
                        'timestamp': fee.paid_date.strftime('%Y-%m-%d %H:%M:%S') if fee.paid_date else ''
                    }
        except Exception as e:
            flash(f"Error retrieving fee: {str(e)}", "error")
    
    if not fee_info:
        flash('Fee record not found', 'error')
        return redirect(url_for('dashboard'))
    
    return render_template('edit_fee.html', member=member, month=month, fee=fee_info)

@app.route('/member/<member_id>/edit', methods=['GET', 'POST'])
def edit_member(member_id):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    member = gym.get_member(member_id)
    if not member:
        flash('Member not found!', 'error')
        return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        name = request.form.get('name')
        phone = request.form.get('phone')
        email = request.form.get('email')
        membership_type = request.form.get('membership_type')
        joined_date = request.form.get('joined_date')
        
        if gym.update_member(member_id, name, phone, membership_type, joined_date, email):
            flash('Member updated successfully!', 'success')
            return redirect(url_for('member_details', member_id=member_id))
        else:
            flash('Update failed!', 'error')
    
    return render_template('edit_member.html', member=member)

@app.route('/member/<member_id>/delete', methods=['POST'])
def delete_member(member_id):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    if gym.delete_member(member_id):
        # Audit Log
        user_id = auth_manager.get_user_id(session.get('username'))
        if user_id:
            security_manager.log_action(user_id, 'MEMBER_DELETE', {'member_id': member_id}, request.remote_addr, request.user_agent.string)
        
        flash('Member deleted successfully!', 'success')
    else:
        flash('Delete failed!', 'error')
        
    return redirect(url_for('dashboard'))

@app.route('/settings', methods=['GET', 'POST'])
def settings():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    if request.method == 'POST':
        name = request.form.get('gym_name')
        currency = request.form.get('currency', '$')
        logo_path = None
        
        if 'gym_logo' in request.files:
            file = request.files['gym_logo']
            if file and file.filename and allowed_file(file.filename):
                filename = secure_filename(f"logo_{datetime.now().strftime('%Y%m%d%H%M%S')}_{file.filename}")
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                file.save(filepath)
                logo_path = filename
        
        if gym.update_gym_details(name, logo_path, currency):
            flash('Gym settings updated successfully!', 'success')
        else:
            flash('Failed to update settings!', 'error')
        return redirect(url_for('settings'))

    payments = []
    subscription = {}
    
    if 'logged_in' in session:
        username = session['username']
        user = auth_manager.session.query(User).filter_by(email=username).first()
        
        if user:
            # Get payments from JSON (Legacy) or DB (Future)
            # Currently payments are stored in JSON in legacy mode
            if auth_manager.legacy:
                legacy_user = auth_manager.users.get(username, {})
                payments = legacy_user.get('payments', [])
            
            # Prepare Subscription Data
            is_active = auth_manager.is_subscription_active(username)
            days_left = 0
            if user.subscription_expiry:
                days_left = (user.subscription_expiry - datetime.utcnow()).days
            
            subscription = {
                'market': user.market or 'US',
                'status': 'Active' if is_active else 'Expired',
                'expiry': user.subscription_expiry.strftime('%Y-%m-%d') if user.subscription_expiry else 'Lifetime',
                'days_left': days_left,
                'is_trial': False # Simplify for now
            }
        
    return render_template('settings.html', details=gym.get_gym_details(), payments=payments, subscription=subscription)

@app.route('/restore_backup', methods=['POST'])
def restore_backup():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    if 'backup_file' not in request.files:
        flash('No file selected!', 'error')
        return redirect(url_for('settings'))
        
    file = request.files['backup_file']
    if file.filename == '':
        flash('No file selected!', 'error')
        return redirect(url_for('settings'))
        
    if file and file.filename.endswith('.json'):
        try:
            # Read and validate JSON
            data = json.load(file)
            
            # Simple validation check (must have 'members' key)
            if 'members' not in data:
                flash('Invalid backup file! Missing member data.', 'error')
                return redirect(url_for('settings'))
            
            # Save to current gym's data file (legacy mode only)
            if gym.legacy and hasattr(gym, 'data_file'):
                with open(gym.data_file, 'w') as f:
                    json.dump(data, f, indent=2)
                flash('‚úÖ Data restored successfully! Please log in again.', 'success')
                return redirect(url_for('logout'))
            else:
                # Database mode: Import JSON data
                success, message = gym.import_json_data(data)
                if success:
                    flash(f'‚úÖ {message}', 'success')
                else:
                    flash(f'‚ö†Ô∏è Import Error: {message}', 'error')
                return redirect(url_for('settings'))
            
        except Exception as e:
            flash(f'Error restoring data: {str(e)}', 'error')
    else:
        flash('Invalid file type! Please upload a JSON file.', 'error')
        
    return redirect(url_for('settings'))

@app.route('/merge_duplicates', methods=['POST'])
def merge_duplicates():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    try:
        merged_count = gym.merge_members()
        if merged_count > 0:
            flash(f'‚úÖ Successfully merged {merged_count} duplicate members!', 'success')
        else:
            flash('No duplicates found.', 'info')
            
    except Exception as e:
        flash(f'Error merging duplicates: {str(e)}', 'error')
        
    return redirect(url_for('settings'))

@app.route('/receipt/<member_id>/<month>')
def generate_receipt(member_id, month):
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    member = gym.get_member(member_id)
    if not member or not gym.is_fee_paid(member_id, month):
        flash('Fee record not found!', 'error')
        return redirect(url_for('member_details', member_id=member_id))
    
    # Get fee data
    fee_info = None
    if gym.legacy and hasattr(gym, 'data'):
        if member_id in gym.data.get('fees', {}) and month in gym.data['fees'][member_id]:
            fee_info = gym.data['fees'][member_id][month]
    else:
        # Database mode
        try:
            from models import get_session, Fee
            session = get_session()
            if session:
                fee = session.query(Fee).filter_by(member_id=member_id, month=month).first()
                if fee:
                    fee_info = {
                        'amount': fee.amount,
                        'date': fee.paid_date.strftime('%Y-%m-%d') if fee.paid_date else '',
                        'timestamp': fee.paid_date.strftime('%Y-%m-%d %H:%M:%S') if fee.paid_date else ''
                    }
                session.close()
        except:
            pass
    
    if not fee_info:
        flash('Fee record not found', 'error')
        return redirect(url_for('dashboard'))

    # Create PDF
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter
    
    gym_details = gym.get_gym_details()
    
    # Header
    c.setFont("Helvetica-Bold", 24)
    c.drawString(50, height - 50, gym_details['name'])
    
    if gym_details.get('logo'):
        logo_path = os.path.join(app.config['UPLOAD_FOLDER'], gym_details['logo'])
        if os.path.exists(logo_path):
            try:
                img = ImageReader(logo_path)
                c.drawImage(img, width - 100, height - 80, width=50, height=50, preserveAspectRatio=True)
            except:
                pass

    c.setFont("Helvetica-Bold", 18)
    c.drawString(50, height - 100, "PAYMENT RECEIPT")
    
    c.setFont("Helvetica", 12)
    c.drawString(50, height - 130, f"Date: {datetime.now().strftime('%Y-%m-%d')}")
    c.drawString(50, height - 150, f"Receipt #: {member_id}-{month.replace('-', '')}")
    
    # Details
    y = height - 200
    c.drawString(50, y, f"Member: {member['name']} (ID: {member_id})")
    c.drawString(50, y - 20, f"Month Paid: {month}")
    c.drawString(50, y - 40, f"Amount Paid: ${fee_info['amount']}")
    c.drawString(50, y - 60, f"Payment Date: {fee_info['paid_date']}")
    
    # Footer
    c.setFont("Helvetica-Oblique", 10)
    c.drawString(50, y - 120, "Thank you for your business!")
    
    c.save()
    buffer.seek(0)
    
    return send_file(buffer, download_name=f'receipt_{member_id}_{month}.pdf', as_attachment=True, mimetype='application/pdf')

@app.route('/bulk_import', methods=['GET', 'POST'])
def bulk_import():
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    if request.method == 'POST':
        action = request.form.get('action', 'upload')
        
        # STEP 1: Upload & Preview
        if action == 'upload':
            if 'import_file' not in request.files:
                flash('No file selected!', 'error')
                return redirect(url_for('bulk_import'))
            
            file = request.files['import_file']
            if file.filename == '':
                flash('No file selected!', 'error')
                return redirect(url_for('bulk_import'))
            
            # Validate file extension
            if not (file.filename.lower().endswith('.xlsx') or file.filename.lower().endswith('.csv')):
                flash('Invalid file format! Use .xlsx or .csv files only.', 'error')
                return redirect(url_for('bulk_import'))
            
            try:
                # Save file temporarily
                upload_folder = app.config.get('UPLOAD_FOLDER', '/tmp')
                if not os.access(upload_folder, os.W_OK):
                    upload_folder = '/tmp'
                
                filename = secure_filename(f"import_{datetime.now().strftime('%Y%m%d%H%M%S')}_{file.filename}")
                filepath = os.path.join(upload_folder, filename)
                file.save(filepath)
                
                # Validate and preview import data
                from import_validator import ImportValidator
                import openpyxl
                
                # Read Excel data
                wb = openpyxl.load_workbook(filepath)
                ws = wb.active
                
                # Convert to list of dicts
                headers = [cell.value for cell in ws[1]]
                rows_data = []
                for row in ws.iter_rows(min_row=2, values_only=True):
                    row_dict = {headers[i]: row[i] for i in range(len(headers)) if i < len(row)}
                    rows_data.append(row_dict)
                
                # Validate
                validator = ImportValidator(gym)
                validation_results = validator.validate_import_data(rows_data)
                
                # Store in session for confirmation
                session['import_file_path'] = filepath
                session['import_validation'] = {
                    'summary': validation_results,
                    'filename': file.filename
                }
                
                return redirect(url_for('import_preview'))
                
            except Exception as e:
                flash(f'‚ùå Error processing file: {str(e)}', 'error')
                return redirect(url_for('bulk_import'))
        
        # STEP 2: Confirm Import (from preview)
        elif action == 'confirm':
            filepath = session.get('import_file_path')
            if not filepath or not os.path.exists(filepath):
                flash('Session expired. Please upload file again.', 'error')
                return redirect(url_for('bulk_import'))
            
            try:
                # Get duplicate strategy
                duplicate_strategy = request.form.get('duplicate_strategy', 'skip')
                
                # Process import
                success_count, error_count, errors = gym.bulk_import_members(
                    filepath, 
                    duplicate_strategy=duplicate_strategy
                )
                
                # Clean up
                try:
                    os.remove(filepath)
                    session.pop('import_file_path', None)
                    session.pop('import_validation', None)
                except:
                    pass
                
                # Show results
                if success_count > 0:
                    # Audit Log
                    user_id = auth_manager.get_user_id(session.get('username'))
                    if user_id:
                        security_manager.log_action(user_id, 'BULK_IMPORT', 
                                                   {'success_count': success_count, 'duplicate_strategy': duplicate_strategy}, 
                                                   request.remote_addr, request.user_agent.string)
                                                   
                    flash(f'‚úÖ Successfully imported {success_count} members!', 'success')
                    return redirect(url_for('dashboard'))
                if error_count > 0:
                    flash(f'‚ö†Ô∏è {error_count} errors occurred.', 'error')
                    for error in errors[:5]:
                        flash(error, 'error')
                
                return redirect(url_for('bulk_import'))
                
            except Exception as e:
                flash(f'‚ùå Import failed: {str(e)}', 'error')
                return redirect(url_for('bulk_import'))
    
    # Clear any stale session data
    session.pop('import_file_path', None)
    session.pop('import_validation', None)
    
    return render_template('bulk_import.html')

@app.route('/import_preview')
def import_preview():
    """Show preview of import data with validation results"""
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    validation_data = session.get('import_validation')
    if not validation_data:
        flash('No import data found. Please upload a file first.', 'error')
        return redirect(url_for('bulk_import'))
    
    # Apply duplicate handling preview
    from import_validator import ImportValidator
    validator = ImportValidator(gym)
    
    # Get summary
    summary = validation_data['summary']
    duplicate_count = sum(1 for row in summary['rows'] if row.get('existing_member'))
    
    return render_template('import_preview.html',
                         validation=summary,
                         filename=validation_data['filename'],
                         duplicate_count=duplicate_count)

@app.route('/download_template')
def download_template():
    """Download sample Excel template for bulk import - USING OPENPYXL (NO PANDAS)"""
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    from openpyxl import Workbook
    from openpyxl.styles import Font, PatternFill, Alignment
    from io import BytesIO
    
    # Create workbook
    wb = Workbook()
    ws = wb.active
    ws.title = "Members"
    
    # Headers
    headers = ['Name', 'Phone', 'Email', 'Membership Type', 'Joined Date', 'Status', 'Paid Month', 'Amount']
    
    # Style for headers
    header_font = Font(bold=True, color="FFFFFF")
    header_fill = PatternFill(start_color="333333", end_color="333333", fill_type="solid")
    center_align = Alignment(horizontal='center')
    
    for col_num, header in enumerate(headers, 1):
        cell = ws.cell(row=1, column=col_num)
        cell.value = header
        cell.font = header_font
        cell.fill = header_fill
        cell.alignment = center_align
    
    # Sample Data (with Payment Example)
    current_month = datetime.now().strftime('%Y-%m')
    sample_data = [
        ['John Doe', '03001234567', 'john@example.com', 'Gym', '2025-01-01', 'Paid', current_month, 2500],
        ['Jane Smith', '03117654321', 'jane@example.com', 'Gym + Cardio', '2025-01-05', 'Unpaid', '', ''],
        ['Ahmed Ali', '03009876543', 'ahmed@example.com', 'Gym', '2025-01-10', 'Paid', current_month, 3000]
    ]
    
    for row_num, row_data in enumerate(sample_data, 2):
        for col_num, cell_value in enumerate(row_data, 1):
            ws.cell(row=row_num, column=col_num).value = cell_value
    
    # Adjust column widths
    column_widths = [20, 15, 25, 20, 15]
    for i, width in enumerate(column_widths, 1):
        ws.column_dimensions[chr(64 + i)].width = width
    
    # Save to buffer
    output = BytesIO()
    wb.save(output)
    output.seek(0)
    
    return send_file(output, download_name='member_import_template.xlsx', as_attachment=True)

@app.route('/member/<member_id>/wallet_pass')
def generate_wallet_pass(member_id):
    """Generate Google Wallet pass for member"""
    gym = get_gym()
    if not gym: return redirect(url_for('auth'))
    
    member = gym.get_member(member_id)
    if not member:
        flash('Member not found!', 'error')
        return redirect(url_for('dashboard'))
    
    # Initialize wallet pass generator
    wallet = GymWalletPass()
    
    if not wallet.is_configured():
        flash('‚ö†Ô∏è Google Wallet not configured. Contact admin to set up.', 'error')
        return redirect(url_for('member_details', member_id=member_id))
    
    # Get gym details
    gym_details = gym.get_gym_details()
    
    # Create or update the loyalty class (one per gym)
    class_id = wallet.create_class(
        gym_name=gym_details['name'],
        gym_logo_url=None  # Can add logo URL later
    )
    
    if not class_id:
        flash('‚ùå Failed to create wallet class. Check credentials.', 'error')
        return redirect(url_for('member_details', member_id=member_id))
    
    # Generate the "Add to Google Wallet" URL
    save_url = wallet.create_jwt_save_url(
        member_id=member_id,
        member_name=member['name'],
        member_phone=member['phone'],
        gym_name=gym_details['name']
    )
    
    if save_url:
        # Redirect to Google Wallet
        return redirect(save_url)
    else:
        flash('‚ùå Failed to generate wallet pass. Check configuration.', 'error')
        return redirect(url_for('member_details', member_id=member_id))




@app.route('/fix_db')
def fix_database_schema():
    """Bulletproof database migration - CANNOT FAIL"""
    from sqlalchemy import text
    import traceback
    
    results = []
    
    try:
        from models import get_session
        session = get_session()
        
        # Wrap EVERYTHING in try-catch
        operations = [
            ("CREATE TABLE body_measurements", """
                CREATE TABLE IF NOT EXISTS body_measurements (
                    id SERIAL PRIMARY KEY,
                    member_id INTEGER REFERENCES members(id),
                    weight FLOAT,
                    body_fat FLOAT,
                    chest FLOAT,
                    waist FLOAT,
                    arms FLOAT,
                    notes TEXT,
                    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """),
            ("CREATE TABLE member_notes", """
                CREATE TABLE IF NOT EXISTS member_notes (
                    id SERIAL PRIMARY KEY,
                    member_id INTEGER REFERENCES members(id),
                    note TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """),
            ("ADD members.birthday", "ALTER TABLE members ADD COLUMN IF NOT EXISTS birthday DATE"),
            ("ADD members.last_check_in", "ALTER TABLE members ADD COLUMN IF NOT EXISTS last_check_in TIMESTAMP"),
            ("ADD attendance.created_at", "ALTER TABLE attendance ADD COLUMN IF NOT EXISTS created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP"),
            ("ADD attendance.emotion", "ALTER TABLE attendance ADD COLUMN IF NOT EXISTS emotion VARCHAR(50)"),
            ("ADD attendance.confidence", "ALTER TABLE attendance ADD COLUMN IF NOT EXISTS confidence FLOAT"),
            ("ADD users.market", "ALTER TABLE users ADD COLUMN IF NOT EXISTS market VARCHAR(50) DEFAULT 'US'"),
            ("ADD users.subscription_expiry", "ALTER TABLE users ADD COLUMN IF NOT EXISTS subscription_expiry TIMESTAMP"),
        ]
        
        for name, sql in operations:
            try:
                session.execute(text(sql))
                session.commit()
                results.append(f"‚úÖ {name}")
            except Exception as e:
                session.rollback()
                error_msg = str(e)
                if "already exists" in error_msg or "duplicate" in error_msg.lower():
                    results.append(f"‚ÑπÔ∏è {name} (already exists)")
                else:
                    results.append(f"‚ö†Ô∏è {name}: {error_msg[:100]}")
        
        session.close()
        
        # Build success HTML
        html = """
        <html>
        <head>
            <title>Database Fixed</title>
            <style>
                body {
                    font-family: 'Inter', Arial, sans-serif;
                    background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
                    color: white;
                    padding: 2rem;
                    margin: 0;
                }
                .container {
                    max-width: 800px;
                    margin: 0 auto;
                    background: rgba(30, 41, 59, 0.8);
                    padding: 2.5rem;
                    border-radius: 16px;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
                }
                h1 {
                    color: #8b5cf6;
                    margin-bottom: 2rem;
                    font-size: 2rem;
                }
                .result {
                    padding: 0.75rem 1rem;
                    margin: 0.5rem 0;
                    border-radius: 8px;
                    background: rgba(139, 92, 246, 0.1);
                    border-left: 4px solid #8b5cf6;
                }
                .success { border-left-color: #10b981; background: rgba(16, 185, 129, 0.1); }
                .info { border-left-color: #06b6d4; background: rgba(6, 182, 212, 0.1); }
                .warning { border-left-color: #f59e0b; background: rgba(245, 158, 11, 0.1); }
                .btn {
                    display: inline-block;
                    padding: 1rem 2rem;
                    background: linear-gradient(135deg, #8b5cf6, #06b6d4);
                    color: white;
                    text-decoration: none;
                    border-radius: 12px;
                    font-weight: 600;
                    margin-top: 2rem;
                    transition: transform 0.2s;
                }
                .btn:hover { transform: translateY(-2px); }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>üîß Database Migration Complete!</h1>
        """
        
        for result in results:
            css_class = "success" if "‚úÖ" in result else ("info" if "‚ÑπÔ∏è" in result else "warning")
            html += f'<div class="result {css_class}">{result}</div>'
        
        html += """
                <a href="/" class="btn">‚Üí Go to Dashboard</a>
            </div>
        </body>
        </html>
        """
        
        return html
        
    except Exception as e:
        # Even if EVERYTHING fails, show helpful error
        return f"""
        <html>
        <head><title>Migration Error</title></head>
        <body style='font-family: Arial; padding: 2rem; background: #1e293b; color: white;'>
            <h1 style='color: #ef4444;'>‚ùå Database Migration Error</h1>
            <div style='background: rgba(239, 68, 68, 0.1); padding: 1.5rem; border-radius: 12px; border-left: 4px solid #ef4444;'>
                <strong>Error:</strong><br>
                <pre style='color: #fca5a5; margin-top: 1rem;'>{str(e)}</pre>
                <hr style='border-color: rgba(239, 68, 68, 0.3); margin: 1rem 0;'>
                <strong>Traceback:</strong><br>
                <pre style='color: #fca5a5; font-size: 0.85rem;'>{traceback.format_exc()}</pre>
            </div>
            <a href='/' style='display: inline-block; margin-top: 2rem; padding: 1rem 2rem; background: #06b6d4; color: white; text-decoration: none; border-radius: 8px;'>Try Dashboard Anyway</a>
        </body>
        </html>
        """

@app.route('/api/chatbot', methods=['POST'])
def chatbot_api():
    """AI Chatbot API - Smart responses for gym queries"""
    try:
        data = request.get_json()
        message = data.get('message', '').lower().strip()
        
        if not message:
            return jsonify({'error': 'No message provided'}), 400
        
        # Get gym details for personalized responses
        username = session.get('username')
        gym_name = "Gym Manager"
        
        if username:
            try:
                gym_manager = GymManager(username)
                gym_details = gym_manager.get_gym_details()
                gym_name = gym_details.get('name', 'Gym Manager')
            except:
                pass
        
        # Smart response logic
        response = generate_smart_response(message, gym_name, username)
        
        return jsonify({
            'response': response['text'],
            'quick_replies': response.get('quick_replies', [])
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

def generate_smart_response(message, gym_name, username=None):
    """Generate intelligent responses based on message content with a VIP brand voice"""
    
    # Greeting / Start
    if any(word in message for word in ['hi', 'hello', 'hey', 'start', 'salaam', 'aoa']):
        return {
            'text': f"üíé **Welcome to {gym_name} VIP Concierge!**\n\n"
                   f"How can I assist you today? I can help you with **Subscriptions**, **Gym Hours**, **Classes**, or **Account** details.\n\n"
                   "What's on your mind? üî•",
            'quick_replies': ['Subscription Plans', 'Gym Hours', 'Our Facilities', 'Contact Us']
        }
    
    # Subscription / Plans (Dedicated Block)
    elif any(word in message for word in ['subscription', 'sub', 'membership', 'tier', 'plan', 'package', 'pricing', 'price']):
        return {
            'text': " ‚ú® **Exclusive Membership Tiers** ‚ú®\n\n"
                   "Choose a plan that fits your fitness journey. You can view all details and **upgrade instantly** here:\n"
                   "üîó **[View & Upgrade Subscription Plans](/subscription_plans)**\n\n"
                   "üèãÔ∏è **Starter VIP** ‚Äî Rs 2,500/mo\n"
                   "üí™ **Professional VIP** ‚Äî Rs 4,500/mo\n"
                   "üëë **Ultimate Elite** ‚Äî Rs 7,500/mo\n\n"
                   "üí° *Pay yearly to save 20%! Click the link above to get started.*",
            'quick_replies': ['Payment Options', 'Gym Hours', 'Book a Tour']
        }
    
    # Hours / Timing
    elif any(word in message for word in ['hour', 'time', 'open', 'close', 'timing', 'schedule']):
        return {
            'text': f"üïí **{gym_name} Operational Hours:**\n\n"
                   "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                   "üìÖ **Mon - Fri:** 6:00 AM - 11:00 PM\n"
                   "üìÖ **Sat - Sun:** 7:00 AM - 9:00 PM\n"
                   "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                   "We are open 365 days a year to keep you consistent! üí™",
            'quick_replies': ['Subscription Plans', 'Our Facilities']
        }
    
    # Payment / Bills
    elif any(word in message for word in ['payment', 'pay', 'due', 'bill', 'fee', 'charge', 'invoice', 'gateway']):
        return {
            'text': "üí≥ **VIP Payment Portal Info**\n\n"
                   "We offer multiple convenient ways to pay. Manage your billing details here:\n"
                   "üîó **[Go to Payment Settings](/settings)**\n\n"
                   "‚úÖ **Direct Transfer:** JazzCash / EasyPaisa\n"
                   "‚úÖ **Digital Card:** Visa, Mastercard, Amex\n"
                   "‚úÖ **At Desk:** Cash or Card swipe\n\n"
                   "üìç Payments are due by the **5th** of each month.\n"
                   "üí° *Click 'Go to Payment Settings' to save your card for auto-pay.*",
            'quick_replies': ['Subscription Plans', 'Check My Balance', 'Contact Support']
        }
    
    # Facilities / Equipment
    elif any(word in message for word in ['facility', 'equipment', 'amenity', 'locker', 'spa', 'shower']):
        return {
            'text': "üè¢ **Premium Amenities & Equipment**\n\n"
                   "Our facility is equipped with top-of-the-line gear:\n"
                   "üöÄ **Strength Room:** Hammer Strength & Rogue rigs\n"
                   "üèÉ **Cardio Suite:** Peloton bikes & Technogym treadmills\n"
                   "üßò **Studio:** Yoga, Pilates, & HIIT zones\n"
                   "üöø **Lounge:** Luxury showers & spa recovery\n\n"
                   "Experience the best in the city! üí´",
            'quick_replies': ['View Schedule', 'Subscription Plans']
        }
    
    # Contact / Support
    elif any(word in message for word in ['contact', 'phone', 'call', 'support', 'help', 'whatsapp', 'address']):
        return {
            'text': "üìû **Get in Touch with VIP Support**\n\n"
                   "We are here to assist you 24/7:\n\n"
                   "üì± **WhatsApp:** +92 300 1234567\n"
                   "üìû **Phone:** +92 300 1234567\n"
                   "‚úâÔ∏è **Email:** support@fitnessmanagement.site\n\n"
                   "üìç **Visit Us:** Main Boulevard, Fitness Plaza, Lahore.\n\n"
                   "Response time: Within 15 minutes! ‚ö°",
            'quick_replies': ['Subscription Plans', 'Gym Hours']
        }
    
    # Default Response
    else:
        return {
            'text': "ü§ñ **I'm your Fitness HQ AI.**\n\n"
                   "I'm here to help you dominate your goals. Ask me about:\n\n"
                   "‚≠ê **Membership Options**\n"
                   "‚è∞ **Timing & Schedules**\n"
                   "üí≥ **Billing & Payments**\n"
                   "üèãÔ∏è **Facilities & Trainers**\n\n"
                   "How can I serve you today?",
            'quick_replies': ['Subscription Plans', 'Gym Hours', 'Contact Us']
        }

if __name__ == '__main__':
    # Modular routes are now initialized at the global scope for Gunicorn compatibility
    
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=False)
